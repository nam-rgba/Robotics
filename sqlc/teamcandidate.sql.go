// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: teamcandidate.sql

package sqlc

import (
	"context"
	"database/sql"
)

const candidateResponse = `-- name: CandidateResponse :exec
UPDATE team_candidate SET invitation_status = $3 WHERE team_id = $1 AND can_id = $2 RETURNING team_id, can_id, invitation_status
`

type CandidateResponseParams struct {
	TeamID           int64          `json:"team_id"`
	CanID            int64          `json:"can_id"`
	InvitationStatus sql.NullString `json:"invitation_status"`
}

func (q *Queries) CandidateResponse(ctx context.Context, arg CandidateResponseParams) error {
	_, err := q.db.ExecContext(ctx, candidateResponse, arg.TeamID, arg.CanID, arg.InvitationStatus)
	return err
}

const getCandidates = `-- name: GetCandidates :many
SELECT team_id, can_id, invitation_status FROM team_candidate WHERE team_id = $1
`

func (q *Queries) GetCandidates(ctx context.Context, teamID int64) ([]TeamCandidate, error) {
	rows, err := q.db.QueryContext(ctx, getCandidates, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TeamCandidate
	for rows.Next() {
		var i TeamCandidate
		if err := rows.Scan(&i.TeamID, &i.CanID, &i.InvitationStatus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamCandidates = `-- name: GetTeamCandidates :many
SELECT team_id, can_id, invitation_status FROM team_candidate WHERE team_id = $1
`

func (q *Queries) GetTeamCandidates(ctx context.Context, teamID int64) ([]TeamCandidate, error) {
	rows, err := q.db.QueryContext(ctx, getTeamCandidates, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TeamCandidate
	for rows.Next() {
		var i TeamCandidate
		if err := rows.Scan(&i.TeamID, &i.CanID, &i.InvitationStatus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inviteByEmail = `-- name: InviteByEmail :one
INSERT INTO team_candidate (team_id, can_id, invitation_status) VALUES ($1, $2, 'pending') RETURNING team_id, can_id, invitation_status
`

type InviteByEmailParams struct {
	TeamID int64 `json:"team_id"`
	CanID  int64 `json:"can_id"`
}

func (q *Queries) InviteByEmail(ctx context.Context, arg InviteByEmailParams) (TeamCandidate, error) {
	row := q.db.QueryRowContext(ctx, inviteByEmail, arg.TeamID, arg.CanID)
	var i TeamCandidate
	err := row.Scan(&i.TeamID, &i.CanID, &i.InvitationStatus)
	return i, err
}

const removeCandidate = `-- name: RemoveCandidate :one
DELETE FROM team_candidate WHERE team_id = $1 AND can_id = $2 RETURNING team_id, can_id, invitation_status
`

type RemoveCandidateParams struct {
	TeamID int64 `json:"team_id"`
	CanID  int64 `json:"can_id"`
}

func (q *Queries) RemoveCandidate(ctx context.Context, arg RemoveCandidateParams) (TeamCandidate, error) {
	row := q.db.QueryRowContext(ctx, removeCandidate, arg.TeamID, arg.CanID)
	var i TeamCandidate
	err := row.Scan(&i.TeamID, &i.CanID, &i.InvitationStatus)
	return i, err
}
